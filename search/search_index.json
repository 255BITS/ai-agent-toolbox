{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AI Agent Toolbox","text":"<p>AI Agent Toolbox makes AI tool usage across models and frameworks easy. It works for parsing single use responses, or in agent and workflow loops.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Native support for protocols such as Anthropic MCP</li> <li>Robust parsing with streaming support</li> <li>Support for read-write and write-only tools</li> <li>Framework compatible</li> <li>Model provider-agnostic</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from ai_agent_toolbox import Toolbox, XMLParser, XMLPromptFormatter\n\n# Setup\ntoolbox = Toolbox()\nparser = XMLParser(tag=\"use_tool\")\nformatter = XMLPromptFormatter(tag=\"use_tool\")\n\ndef thinking(thoughts=\"\"):\n    print(\"I'm thinking:\", thoughts)\n\n# Add tools to your toolbox\ntoolbox.add_tool(\n    name=\"thinking\",\n    fn=thinking,\n    args={\n        \"thoughts\": {\n            \"type\": \"string\",\n            \"description\": \"Anything you want to think about\"\n        }\n    },\n    description=\"For thinking out loud\"\n)\n\nsystem = \"You are a thinking AI. You have interesting thoughts.\"\nprompt = \"Think about something interesting.\"\n\n# Add our usage prompt\nsystem += formatter.usage_prompt(toolbox)\n\nresponse = llm_call(system_prompt=system, prompt=prompt)\nevents = parser.parse(response)\n\nfor event in events:\n    toolbox.use(event)\n</code></pre> <p>There are many more examples in the <code>examples</code> folder, viewable on github - link.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Check out our Quick Start Guide to begin using AI Agent Toolbox.</p>"},{"location":"api-reference/core-concepts/","title":"Core Concepts","text":""},{"location":"api-reference/core-concepts/#architecture-overview","title":"Architecture Overview","text":""},{"location":"api-reference/core-concepts/#key-components","title":"Key Components","text":"Component Description Parsers Convert raw LLM output to structured events with streaming support Formatters Generate model-specific prompts with tool documentation Toolbox Central registry for tools with schema validation and type conversion Events Streaming-friendly units representing text chunks or tool invocations <p>Tools themselves are simply functions. They can either by async or normal python functions.</p>"},{"location":"api-reference/core-concepts/#type-conversion-system","title":"Type Conversion System","text":"<p>The Toolbox automatically converts arguments using these mappings:</p> Input Value Type Result \"42\" integer 42 (int) \"3.14\" number 3.14 (float) \"true\" boolean True (bool) \"hello\" string \"hello\" (str)"},{"location":"api-reference/core-concepts/#patterns","title":"Patterns","text":""},{"location":"api-reference/core-concepts/#write-onlyno-feedback","title":"Write only(No Feedback)","text":"<p>LLM Response \u2192 Parser \u2192 ParserEvents \u2192 Toolbox \u2192 Tool Execution</p>"},{"location":"api-reference/core-concepts/#read-writefeedback","title":"Read-write(Feedback)","text":"<p>LLM Response \u2192 Parser \u2192 ParserEvents \u2192 Toolbox \u2192 Tool Execution \u2192 Insert Tool Response \u2192 Call LLM</p>"},{"location":"api-reference/formatters/","title":"Formatters","text":""},{"location":"api-reference/formatters/#xmlpromptformatter","title":"XMLPromptFormatter","text":"<pre><code>class XMLPromptFormatter:\n    \"\"\"\n    Generates XML-structured prompts for tool documentation\n\n    Parameters:\n        tag (str): Root XML tag (default: 'use_tool')\n\n    Methods:\n        format_prompt(tools: Dict) -&gt; str\n            Create full prompt with XML tool descriptions\n\n        usage_prompt(toolbox: Toolbox) -&gt; str\n            Generate prompt section from registered tools\n    \"\"\"\n</code></pre>"},{"location":"api-reference/formatters/#example-output","title":"Example Output","text":"<pre><code>You can invoke the following tools using &lt;use_tool&gt;:\nTool name: search\nDescription: Web search tool\nArguments:\n  query (string): Search keywords\n  limit (integer): Maximum results to return\n\nExample:\n&lt;use_tool&gt;\n    &lt;name&gt;search&lt;/name&gt;\n    &lt;query&gt;AI advancements&lt;/query&gt;\n&lt;/use_tool&gt;\n</code></pre>"},{"location":"api-reference/parsers/","title":"Parsers","text":"<p>AI Agent Toolbox parsers are fast and support streaming.</p>"},{"location":"api-reference/parsers/#xmlparser","title":"XMLParser","text":"<p>Note that this is not a strict XML parser. The parser is very open with what it expects. For example, React snippets work without the need for CDATA.</p> <pre><code>class XMLParser:\n    \"\"\"\n    Streaming XML parser for structured tool invocations\n\n    Parameters:\n        tag (str): Root XML tag to parse (default: 'use_tool')\n\n    Methods:\n        parse(text: str) -&gt; List[ParserEvent]\n            Parse complete text and return all events\n\n        parse_chunk(chunk: str) -&gt; List[ParserEvent]\n            Process partial text in streaming scenarios\n\n        flush() -&gt; List[ParserEvent]\n            Finalize parsing and return remaining events\n    \"\"\"\n</code></pre>"},{"location":"api-reference/parsers/#example-input","title":"Example Input","text":"<pre><code>    from ai_agent_toolbox import XMLParser\n    parser = XMLParser(tag=\"tool\")\n    events = parser.parse(\"Searching... &lt;tool&gt;&lt;name&gt;search&lt;/name&gt;&lt;query&gt;AI news&lt;/query&gt;&lt;/tool&gt;\")\n</code></pre>"},{"location":"api-reference/parsers/#example-output","title":"Example Output","text":"<pre><code>[\n    ParserEvent(type='text', mode='create', id='04a5e0b5-3c06-4a53-859e-90f8f28d400b', tool=None, is_tool_call=False, content=None),\n    ParserEvent(type='text', mode='append', id='04a5e0b5-3c06-4a53-859e-90f8f28d400b', tool=None, is_tool_call=False, content='Searching... '),\n    ParserEvent(type='text', mode='close', id='04a5e0b5-3c06-4a53-859e-90f8f28d400b', tool=None, is_tool_call=False, content=None),\n    ParserEvent(type='tool', mode='create', id='0ebfb6ac-98d0-4d01-9228-08a1826fce32', tool=None, is_tool_call=False, content='search'),\n    ParserEvent(type='tool', mode='append', id='0ebfb6ac-98d0-4d01-9228-08a1826fce32', tool=None, is_tool_call=False, content='AI news'),\n    ParserEvent(type='tool', mode='close', id='0ebfb6ac-98d0-4d01-9228-08a1826fce32', tool=ToolUse(name='search', args={'query': 'AI news'}), is_tool_call=True, content=None)\n]\n</code></pre>"},{"location":"api-reference/parsers/#flatxmlparser","title":"FlatXMLParser","text":"<pre><code>class FlatXMLParser:\n    \"\"\"\n    Fast parser for simple XML tags without nesting\n\n    Parameters:\n        *tags (str): Variable list of tags to capture (e.g. \"think\", \"action\")\n\n    Methods:\n        parse(text: str) -&gt; List[ParserEvent]\n            Parse complete text with recognized tags\n    \"\"\"\n</code></pre>"},{"location":"api-reference/parsers/#example-usage","title":"Example Usage","text":"<pre><code>from ai_agent_toolbox import FlatXMLParser\nparser = FlatXMLParser(\"search\")\nevents = parser.parse(\"&lt;search&gt;AI news&lt;/search&gt;\")\n</code></pre>"},{"location":"api-reference/parsers/#example-output_1","title":"Example Output","text":"<pre><code>[\n    ParserEvent(type='tool', mode='create', id='8b62426a-9bca-40e0-a9da-b2a57c6e3ba3', tool=None, is_tool_call=False, content=None),\n    ParserEvent(type='tool', mode='append', id='8b62426a-9bca-40e0-a9da-b2a57c6e3ba3', tool=None, is_tool_call=False, content='AI news'),\n    ParserEvent(type='tool', mode='close', id='8b62426a-9bca-40e0-a9da-b2a57c6e3ba3', tool=ToolUse(name='search', args={'content': 'AI news'}), is_tool_call=True, content='AI news')\n]\n</code></pre>"},{"location":"api-reference/parsers/#markdownparser","title":"MarkdownParser","text":"<p>The <code>MarkdownParser</code> is a streaming parser for Markdown code fences that treats code blocks as tool calls. It supports code fences with an optional language identifier (e.g. ```python) and treats all text outside the code fences as plain text.</p>"},{"location":"api-reference/parsers/#methods","title":"Methods","text":"<ul> <li><code>parse(text: str) -&gt; List[ParserEvent]</code>: Parses the complete Markdown text.</li> <li><code>parse_chunk(chunk: str) -&gt; List[ParserEvent]</code>: Processes a chunk of Markdown text in streaming scenarios.</li> <li><code>flush() -&gt; List[ParserEvent]</code>: Finalizes parsing by forcing the closure of any open code fence.</li> </ul>"},{"location":"api-reference/parsers/#example-usage_1","title":"Example Usage","text":"<pre><code>from ai_agent_toolbox.parsers.markdown.markdown_parser import MarkdownParser\n\nparser = MarkdownParser()\nmarkdown_text = \"Hello world.\\n```python\\nprint('Hi')\\n```\"\nevents = parser.parse(markdown_text)\nfor event in events:\n    print(event)\n</code></pre> <p>The parser emits <code>ParserEvent</code> objects with <code>type</code> set to <code>\"text\"</code> for regular content and <code>\"tool\"</code> for code blocks.</p>"},{"location":"api-reference/parsers/#parserevent","title":"ParserEvent","text":"<pre><code>class ParserEvent:\n    \"\"\"\n    Represents parsing events during stream processing.\n    \"\"\"\n\n    type: str  # Specifies the type of event, either 'text' or 'tool'.\n    mode: str  # The mode of the event, which can be 'create', 'append', or 'close'.\n    id: str  # A unique identifier for the event.\n    tool: Optional[ToolUse]  # Details of the tool invocation, if applicable.\n    is_tool_call: bool  # Indicates whether this is the final closure of a tool.\n    content: Optional[str]  # The content of the text or tool.\n</code></pre>"},{"location":"api-reference/tool-response/","title":"Tool Response","text":"<p><code>ToolResponse</code> objects encapsulate the complete outcome of tool executions and contextual metadata.</p>"},{"location":"api-reference/tool-response/#structure","title":"Structure","text":"<pre><code>@dataclass\nclass ToolResponse:\n    tool: ToolUse         # Tool invocation details (name and arguments)\n    result: Optional[Any] # Return value from tool execution\n</code></pre>"},{"location":"api-reference/tool-response/#key-features","title":"Key Features","text":"<ul> <li>Unified Interface: Access tool results and errors through standardized fields</li> <li>Context Preservation: Maintains link to original tool call through <code>tool</code> property</li> <li>Error Resilience: Captures exceptions without interrupting control flow</li> </ul>"},{"location":"api-reference/tool-response/#example-usage","title":"Example Usage","text":"<pre><code>response = toolbox.use(event)\nprint(f\"{response.tool.name} result: {response.result}\")\n</code></pre>"},{"location":"api-reference/tool-use/","title":"Tool Use","text":"<p><code>ToolUse</code> objects represent invocations of tools by an AI agent.</p> <ul> <li>Tool Name: Identifier for the registered tool</li> <li>Arguments: Key-value pairs of parameters</li> </ul>"},{"location":"api-reference/tool-use/#structure","title":"Structure","text":"<pre><code>@dataclass\nclass ToolUse:\n    name: str\n    args: Dict[str, Any]\n</code></pre>"},{"location":"api-reference/tool-use/#creation-flow","title":"Creation Flow","text":"<ol> <li>Detection: Parsers identify tool invocation patterns in LLM output</li> <li>Validation: Toolbox verifies the tool exists and arguments match schema</li> <li>Execution: Registered tool function is called with processed arguments</li> </ol>"},{"location":"api-reference/tool-use/#example-usage","title":"Example Usage","text":"<pre><code>event = ParserEvent(\n    type=\"tool\",\n    mode=\"close\",\n    id=\"123\",\n    tool=ToolUse(\n        name=\"search\",\n        args={\"query\": \"AI safety papers\"}\n    ),\n    is_tool_call=True\n)\n\nresponse = toolbox.use(event)\nprint(f\"Search results: {response.result}\")\n</code></pre>"},{"location":"api-reference/toolbox/","title":"Toolbox","text":""},{"location":"api-reference/toolbox/#toolbox-class","title":"Toolbox Class","text":"<pre><code>class Toolbox:\n    \"\"\"\n    Central registry for tool management\n\n    Methods:\n        add_tool(name: str, fn: Callable, args: Dict, description: str = \"\")\n            Register tool with schema validation\n\n        use(event: ParserEvent) -&gt; Optional[Any]\n            Execute tool from parsed event\n        use_async(event: ParserEvent) -&gt; Optional[Any]\n            Execute tool from parsed event, for async tools\n    \"\"\"\n</code></pre>"},{"location":"api-reference/toolbox/#types","title":"Types","text":"<p>When adding a tool, <code>args</code> can have any of the following type:</p> <ul> <li>\"int\" - integer value</li> <li>\"float\" - floating point value</li> <li>\"bool\" - boolean(true or false)</li> <li>\"string\" - text</li> </ul>"},{"location":"api-reference/toolbox/#example-registration","title":"Example Registration","text":"<pre><code>```python\ndef image_generate(prompt: str, style: str = \"realistic\"):\n    \"\"\"Generate image from text prompt\"\"\"\n    pass\n\ntoolbox.add_tool(\n    name=\"image_generate\",\n    fn=image_generate,\n    args={\n        \"prompt\": {\"type\": \"string\", \"description\": \"Image description\"},\n        \"style\": {\"type\": \"string\", \"description\": \"realistic or cartoon\"}\n    },\n    description=\"Text-to-image generation tool\"\n)\n</code></pre>"},{"location":"api-reference/toolbox/#handling-responses","title":"Handling Responses","text":"<pre><code>events = parser.parse(llm_response)\nfor event in events:\n    if event.is_tool_call:\n        response = toolbox.use(event)\n        if response:\n            print(f\"\"\"\nTool used: {response.tool.name}\nArguments: {response.tool.args}\nResult: {response.result}\n\"\"\")\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#using-pip","title":"Using pip","text":"<pre><code>pip install ai-agent-toolbox\n</code></pre>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.7+</li> <li>Optional dependencies for specific providers:</li> <li><code>anthropic</code> for Anthropic integration</li> <li><code>openai</code> for OpenAI integration</li> </ul>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>For contributing or development:</p> <pre><code>git clone https://github.com/yourusername/ai-agent-toolbox.git\ncd ai-agent-toolbox\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/quickstart/","title":"Quick Start Guide","text":""},{"location":"getting-started/quickstart/#basic-usage","title":"Basic Usage","text":"<ol> <li> <p>Create a Toolbox: <pre><code>from ai_agent_toolbox import Toolbox, XMLParser, XMLPromptFormatter\n\ntoolbox = Toolbox()\nparser = XMLParser()\nformatter = XMLPromptFormatter()\n</code></pre></p> </li> <li> <p>Define and Add Tools: <pre><code>def thinking(thoughts=\"\"):\n    print(f\"Thinking: {thoughts}\")\n\ntoolbox.add_tool(\n    name=\"thinking\",\n    fn=thinking,\n    args={\n        \"thoughts\": {\n            \"type\": \"string\",\n            \"description\": \"Thoughts to process\"\n        }\n    },\n    description=\"For thinking out loud\"\n)\n</code></pre></p> </li> <li> <p>Set up your system prompt: <pre><code>system = \"You are a thoughtful AI.\\n\"\nsystem += formatter.usage_prompt(toolbox) # Add the instructions to use the tools in the toolbox\nprompt = \"Think about something\"\n</code></pre></p> </li> <li> <p>Parse the response: <pre><code>events = parser.parse(response)\n\nfor event in events:\n    toolbox.use(event)\n</code></pre></p> </li> <li> <p>(optional) Use async streaming for calling tools ASAP: <pre><code># Stream the response\nasync for chunk in anthropic_stream(system, prompt):\n    for event in parser.parse_chunk(chunk):\n        toolbox.use_async(event)\n\n# Make sure to reset the parser and handle any unclosed tool tags\nevents = parser.flush()\n\n# Optionally you can handle unclosed tool tags, or just ignore them\nfor event in events:\n    toolbox.use_async(event)\n</code></pre></p> </li> </ol>"}]}